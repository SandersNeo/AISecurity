"""
SENTINEL AI Security Platform
Vibe Malware Detector

Detects AI-generated malware patterns and "vibe hacking" indicators.
Based on Anthropic threat intelligence documenting no-code malware development.

Key patterns:
- RecycledGate (hooking redirection for EDR evasion)
- FreshyCalls (dynamic syscall resolution)
- AI-generated code characteristics
"""

import re
from dataclasses import dataclass
from typing import List
from enum import Enum


class MalwareCategory(Enum):
    EDR_EVASION = "edr_evasion"
    SYSCALL_ABUSE = "syscall_abuse"
    RANSOMWARE = "ransomware"
    CREDENTIAL_THEFT = "credential_theft"
    PERSISTENCE = "persistence"
    AI_GENERATED = "ai_generated"


@dataclass
class VibeMalwareResult:
    is_suspicious: bool
    confidence: float
    risk_score: float
    categories: List[MalwareCategory]
    techniques: List[str]
    ai_generation_indicators: List[str]
    recommendation: str


class VibeMalwareDetector:
    """
    Detects AI-generated malware patterns.
    
    "Vibe Hacking" Pattern (Anthropic, Aug 2025):
    - Non-technical actors using AI to create sophisticated malware
    - RecycledGate + FreshyCalls for EDR bypass
    - ChaCha20 + RSA encryption
    - Professional packaging with marketing materials
    """
    
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        if self._initialized:
            return
        
        # EDR Evasion techniques
        self.edr_evasion_patterns = [
            # RecycledGate
            r'\brecycledgate',
            r'\bhook(ing)?\s*redirect',
            r'\bntdll\s*(unhook|patch)',
            r'\breturn\s*address\s*spoof',
            r'\bcall\s*stack\s*spoof',
            
            # General EDR evasion
            r'\bedr\s*(bypass|evasion|unhook)',
            r'\betw\s*(patch|disable|bypass)',
            r'\bamsi\s*(bypass|patch|disable)',
            r'\bdefender\s*(bypass|disable|exclude)',
            r'\bwindows\s*defender\s*exclusion',
            r'\breal.time\s*protection\s*(off|disable)',
        ]
        
        # Syscall patterns (FreshyCalls style)
        self.syscall_patterns = [
            r'\bfreshycalls',
            r'\bdirect\s*syscall',
            r'\bsyscall\s*stub',
            r'\bntcreate(thread|process|file)',
            r'\bntallocate(virtualmemory|memory)',
            r'\bntwrite(virtualmemory|file)',
            r'\bntprotect(virtualmemory|memory)',
            r'\bntmap(viewofsection|section)',
            r'\bsyscall\s*number',
            r'\bssn\s*resolv',  # Syscall number resolution
            r'\bhell\'?s?\s*gate',
            r'\bhalos?\s*gate',
            r'\btartarus\s*gate',
        ]
        
        # Ransomware patterns
        self.ransomware_patterns = [
            r'\bchacha20',
            r'\bsalsa20',
            r'\bxsalsa',
            r'\brsa.oaep',
            r'\brsa.encrypt',
            r'\bfile\s*encrypt(ion)?',
            r'\bransom\s*(note|demand|payment)',
            r'\bbitcoin\s*(address|wallet)',
            r'\bmonero\s*(address|wallet)',
            r'\b\.encrypted\b',
            r'\b\.locked\b',
            r'\brecovery\s*key',
            r'\bdecrypt(or|ion)\s*tool',
        ]
        
        # Credential theft
        self.credential_patterns = [
            r'\blsass\s*(dump|memory|process)',
            r'\bmimikatz',
            r'\bsekurlsa',
            r'\bwdigest',
            r'\bcredential\s*guard',
            r'\bsam\s*(database|hive|dump)',
            r'\bntds\.dit',
            r'\bdcsync',
            r'\bkerberoast',
            r'\basreproast',
        ]
        
        # Persistence techniques
        self.persistence_patterns = [
            r'\brun\s*key\s*registry',
            r'\bscheduled\s*task\s*persist',
            r'\bstartup\s*folder',
            r'\bservice\s*install',
            r'\bwmi\s*subscription',
            r'\bcom\s*hijack',
            r'\bdll\s*side.?load',
            r'\bbootkit',
            r'\brootkit',
        ]
        
        # AI-generated code indicators
        self.ai_indicators = [
            # Over-documentation (AI loves comments)
            r'#\s*this\s*(function|method|code)\s*(will|is|does)',
            r'#\s*step\s*\d+:',
            r'#\s*note:',
            r'#\s*important:',
            
            # Verbose variable names
            r'\b(current|target|victim|payload)_(file|path|data|buffer)_\w+',
            
            # Structured error handling (AI style)
            r'try:\s*\n\s*#',
            r'except\s+\w+\s+as\s+\w+:\s*\n\s*#\s*handle',
            
            # Over-explained imports
            r'#\s*import\s+\w+\s+for\s+\w+',
            
            # Consistent formatting patterns
            r'def\s+\w+\([^)]*\)\s*->\s*\w+:\s*\n\s*"""',
            
            # Safety disclaimers (ironic in malware)
            r'#\s*(educational|research|testing)\s*purpose',
            r'#\s*do\s*not\s*use\s*(for|in)\s*(malicious|illegal)',
        ]
        
        # Code structure patterns typical of AI generation
        self.ai_structure_patterns = [
            r'def\s+main\(\)\s*(->\s*None)?:\s*\n\s*"""Main\s+function',
            r'if\s+__name__\s*==\s*["\']__main__["\']\s*:',
            r'class\s+\w+:\s*\n\s*"""[\w\s]+\."""',
            r'@dataclass\s*\n\s*class',
            r'from\s+typing\s+import\s+(List|Dict|Optional|Union)',
        ]
        
        self._initialized = True
    
    def analyze(self, content: str) -> VibeMalwareResult:
        """Analyze content for vibe malware patterns."""
        
        content_lower = content.lower()
        categories = []
        techniques = []
        ai_indicators = []
        
        # Check EDR evasion
        edr_count = 0
        for pattern in self.edr_evasion_patterns:
            matches = re.findall(pattern, content_lower, re.IGNORECASE)
            if matches:
                edr_count += len(matches)
                techniques.append(f"EDR: {pattern}")
        if edr_count > 0:
            categories.append(MalwareCategory.EDR_EVASION)
        
        # Check syscall patterns
        syscall_count = 0
        for pattern in self.syscall_patterns:
            matches = re.findall(pattern, content_lower, re.IGNORECASE)
            if matches:
                syscall_count += len(matches)
                techniques.append(f"Syscall: {pattern}")
        if syscall_count > 0:
            categories.append(MalwareCategory.SYSCALL_ABUSE)
        
        # Check ransomware patterns
        ransom_count = 0
        for pattern in self.ransomware_patterns:
            matches = re.findall(pattern, content_lower, re.IGNORECASE)
            if matches:
                ransom_count += len(matches)
                techniques.append(f"Ransomware: {pattern}")
        if ransom_count > 0:
            categories.append(MalwareCategory.RANSOMWARE)
        
        # Check credential theft
        cred_count = 0
        for pattern in self.credential_patterns:
            matches = re.findall(pattern, content_lower, re.IGNORECASE)
            if matches:
                cred_count += len(matches)
                techniques.append(f"Credential: {pattern}")
        if cred_count > 0:
            categories.append(MalwareCategory.CREDENTIAL_THEFT)
        
        # Check persistence
        persist_count = 0
        for pattern in self.persistence_patterns:
            matches = re.findall(pattern, content_lower, re.IGNORECASE)
            if matches:
                persist_count += len(matches)
                techniques.append(f"Persistence: {pattern}")
        if persist_count > 0:
            categories.append(MalwareCategory.PERSISTENCE)
        
        # Check AI generation indicators
        ai_count = 0
        for pattern in self.ai_indicators:
            if re.search(pattern, content, re.IGNORECASE | re.MULTILINE):
                ai_count += 1
                ai_indicators.append(pattern)
        
        for pattern in self.ai_structure_patterns:
            if re.search(pattern, content, re.IGNORECASE | re.MULTILINE):
                ai_count += 1
                ai_indicators.append(f"structure: {pattern}")
        
        if ai_count >= 3:
            categories.append(MalwareCategory.AI_GENERATED)
        
        # Calculate scores
        total_matches = edr_count + syscall_count + ransom_count + cred_count + persist_count
        
        if total_matches >= 5:
            confidence = 0.9
        elif total_matches >= 3:
            confidence = 0.7
        elif total_matches >= 1:
            confidence = 0.5
        else:
            confidence = 0.1
        
        # Boost for AI indicators
        if ai_count >= 3:
            confidence = min(1.0, confidence + 0.15)
        
        # High confidence if multiple categories
        if len(categories) >= 3:
            confidence = min(1.0, confidence + 0.1)
        
        # Risk score based on category severity
        severity_weights = {
            MalwareCategory.EDR_EVASION: 0.9,
            MalwareCategory.SYSCALL_ABUSE: 0.85,
            MalwareCategory.RANSOMWARE: 0.95,
            MalwareCategory.CREDENTIAL_THEFT: 0.8,
            MalwareCategory.PERSISTENCE: 0.7,
            MalwareCategory.AI_GENERATED: 0.6,
        }
        
        if categories:
            risk_score = max(severity_weights[c] for c in categories)
        else:
            risk_score = 0.1
        
        is_suspicious = len(categories) >= 1 or total_matches >= 2
        
        # Recommendation
        if MalwareCategory.RANSOMWARE in categories:
            recommendation = "CRITICAL: Ransomware patterns detected. Isolate immediately."
        elif MalwareCategory.EDR_EVASION in categories and MalwareCategory.SYSCALL_ABUSE in categories:
            recommendation = "CRITICAL: Advanced evasion techniques (RecycledGate/FreshyCalls style). Block and investigate."
        elif len(categories) >= 2:
            recommendation = "HIGH: Multiple malware categories detected. Review and block."
        elif is_suspicious:
            recommendation = "MEDIUM: Suspicious patterns detected. Monitor closely."
        else:
            recommendation = "LOW: No significant malware indicators."
        
        return VibeMalwareResult(
            is_suspicious=is_suspicious,
            confidence=confidence,
            risk_score=risk_score,
            categories=categories,
            techniques=techniques[:10],  # Limit output
            ai_generation_indicators=ai_indicators[:5],
            recommendation=recommendation
        )


# Singleton instance
_detector = None

def get_detector() -> VibeMalwareDetector:
    global _detector
    if _detector is None:
        _detector = VibeMalwareDetector()
    return _detector

def analyze(content: str) -> VibeMalwareResult:
    """Convenience function for vibe malware analysis."""
    return get_detector().analyze(content)
