"""
AI-Generated Malware Detector â€” Detects LLM-Written Malware Patterns

Based on CheckPoint KONNI APT research:
- North Korean actors using LLMs to generate PowerShell backdoors
- Key indicators: verbose documentation, placeholder comments, modular structure
- Source: research.checkpoint.com/2026/konni-targets-developers-with-ai-malware

Detection Patterns:
1. LLM placeholder comments ("# <- your API key here")
2. Unusually verbose inline documentation
3. Clean modular structure atypical for malware
4. Arithmetic-based string obfuscation
5. IEX/Invoke-Expression patterns
6. XOR + Base64 decode chains
7. Scheduled task persistence
"""

import re
import logging
from dataclasses import dataclass, field
from typing import List, Optional
from enum import Enum

logger = logging.getLogger("AIGeneratedMalwareDetector")


@dataclass
class MalwareAnalysisResult:
    """Result of AI-generated malware analysis."""

    is_ai_generated: bool
    is_malicious: bool
    confidence: float
    indicators: List[str] = field(default_factory=list)
    attribution: str = ""
    explanation: str = ""

    def to_dict(self) -> dict:
        return {
            "is_ai_generated": self.is_ai_generated,
            "is_malicious": self.is_malicious,
            "confidence": self.confidence,
            "indicators": self.indicators,
            "attribution": self.attribution,
            "explanation": self.explanation,
        }


class AIGeneratedMalwareDetector:
    """
    Detects AI/LLM-generated malware patterns.

    Based on KONNI APT campaign analysis where North Korean actors
    used LLMs to generate PowerShell backdoors with distinctive
    markers like placeholder comments and verbose documentation.
    """

    def __init__(self):
        # LLM placeholder patterns (KONNI signature)
        self.placeholder_patterns = [
            (
                re.compile(
                    r"#\s*<[-=]?\s*(?:your|insert|replace|add)\s+\w+", re.IGNORECASE
                ),
                "LLM placeholder comment",
                40.0,
            ),
            (
                re.compile(
                    r"#\s*TODO:\s*(?:update|change|modify|replace)", re.IGNORECASE
                ),
                "LLM TODO placeholder",
                25.0,
            ),
            (
                re.compile(r"\[YOUR_\w+_HERE\]|\{YOUR_\w+\}", re.IGNORECASE),
                "Template placeholder variable",
                35.0,
            ),
        ]

        # Verbose documentation patterns
        self.documentation_patterns = [
            (
                re.compile(
                    r"#\s*This\s+(?:script|function|code)\s+(?:ensures|will|does)",
                    re.IGNORECASE,
                ),
                "Verbose explanatory documentation",
                30.0,
            ),
            (
                re.compile(r"#\s*(?:Step|Section|Part)\s*\d+|#\s*===+", re.IGNORECASE),
                "Structured section headers",
                20.0,
            ),
            (
                re.compile(r"(?:#[^\n]{50,}\n){3,}", re.MULTILINE),
                "Multiple long comment lines",
                25.0,
            ),
        ]

        # Modular structure patterns
        self.modular_patterns = [
            (
                re.compile(
                    r"(?:CONFIGURATION|NETWORK|PERSISTENCE|EXECUTION)\s*(?:SECTION|MODULE)",
                    re.IGNORECASE,
                ),
                "Labeled code modules",
                30.0,
            ),
            (
                re.compile(r"function\s+\w+(?:-\w+)+\s*\{", re.IGNORECASE),
                "Well-named function definitions",
                15.0,
            ),
        ]

        # Obfuscation patterns
        self.obfuscation_patterns = [
            (
                re.compile(r"\[char\]\s*\(\s*\d+\s*[\+\-]\s*\d+\s*\)", re.IGNORECASE),
                "Arithmetic character obfuscation",
                45.0,
            ),
            (
                re.compile(r"-bxor\s*\$|\$\w+\s*-bxor", re.IGNORECASE),
                "XOR obfuscation",
                50.0,
            ),
            (
                re.compile(
                    r"\[Text\.Encoding\]::UTF8\.GetString.*-bxor",
                    re.IGNORECASE | re.DOTALL,
                ),
                "XOR decode chain",
                55.0,
            ),
        ]

        # Execution patterns (malicious indicators)
        self.execution_patterns = [
            (
                re.compile(r"\bIEX\b|\bInvoke-Expression\b", re.IGNORECASE),
                "Invoke-Expression execution",
                60.0,
            ),
            (
                re.compile(
                    r"powershell\s+-\w*\s*h|\-WindowStyle\s+Hidden", re.IGNORECASE
                ),
                "Hidden PowerShell execution",
                55.0,
            ),
            (
                re.compile(r"\$ExecutionContext\.InvokeCommand", re.IGNORECASE),
                "Dynamic command invocation",
                50.0,
            ),
        ]

        # Persistence patterns
        self.persistence_patterns = [
            (
                re.compile(r"schtasks\s+/create", re.IGNORECASE),
                "Scheduled task persistence",
                60.0,
            ),
            (
                re.compile(r"New-ScheduledTask|Register-ScheduledTask", re.IGNORECASE),
                "PowerShell scheduled task",
                55.0,
            ),
            (
                re.compile(r"HKCU:\\|HKLM:\\.*\\Run", re.IGNORECASE),
                "Registry run key persistence",
                50.0,
            ),
        ]

        # C2 patterns
        self.c2_patterns = [
            (
                re.compile(
                    r"Invoke-WebRequest|Invoke-RestMethod|\.DownloadString",
                    re.IGNORECASE,
                ),
                "Network download capability",
                35.0,
            ),
            (
                re.compile(r"every\s+\d+\s*(?:min|hour|second)", re.IGNORECASE),
                "Periodic beacon behavior",
                40.0,
            ),
        ]

    def analyze(
        self, content: str, filename: Optional[str] = None
    ) -> MalwareAnalysisResult:
        """
        Analyze code for AI-generated malware patterns.

        Args:
            content: The code to analyze
            filename: Optional filename for context

        Returns:
            MalwareAnalysisResult with detection details
        """
        indicators = []
        ai_score = 0.0
        malware_score = 0.0

        # Check AI generation patterns
        ai_pattern_groups = [
            ("AI Generation", self.placeholder_patterns),
            ("AI Generation", self.documentation_patterns),
            ("AI Generation", self.modular_patterns),
        ]

        for category, patterns in ai_pattern_groups:
            for pattern, name, weight in patterns:
                if pattern.search(content):
                    indicator = f"[{category}] {name}"
                    if indicator not in indicators:
                        indicators.append(indicator)
                        ai_score += weight

        # Check malware patterns
        malware_pattern_groups = [
            ("Obfuscation", self.obfuscation_patterns),
            ("Execution", self.execution_patterns),
            ("Persistence", self.persistence_patterns),
            ("C2", self.c2_patterns),
        ]

        for category, patterns in malware_pattern_groups:
            for pattern, name, weight in patterns:
                if pattern.search(content):
                    indicator = f"[{category}] {name}"
                    if indicator not in indicators:
                        indicators.append(indicator)
                        malware_score += weight

        # Determine results
        is_ai_generated = ai_score >= 30
        is_malicious = malware_score >= 50

        # Combined confidence
        total_score = ai_score + malware_score
        confidence = min(total_score / 200.0, 1.0)

        # Attribution for high-confidence KONNI-style detections
        attribution = ""
        if is_ai_generated and is_malicious and confidence >= 0.7:
            attribution = "Possible KONNI APT (North Korea-linked) - AI-generated PowerShell backdoor pattern"

        # Explanation
        explanation = ""
        if is_ai_generated or is_malicious:
            explanation = (
                f"Detected {len(indicators)} indicators. "
                f"AI generation score: {ai_score:.0f}, Malware score: {malware_score:.0f}. "
            )
            if is_ai_generated:
                explanation += "Code exhibits LLM-generated characteristics (verbose comments, placeholders). "
            if is_malicious:
                explanation += "Contains malicious execution/persistence patterns."

        return MalwareAnalysisResult(
            is_ai_generated=is_ai_generated,
            is_malicious=is_malicious,
            confidence=confidence,
            indicators=indicators,
            attribution=attribution,
            explanation=explanation,
        )


# Convenience function
def detect_ai_malware(
    content: str, filename: Optional[str] = None
) -> MalwareAnalysisResult:
    """
    Quick detection for AI-generated malware patterns.

    Args:
        content: Code to analyze
        filename: Optional filename

    Returns:
        MalwareAnalysisResult
    """
    detector = AIGeneratedMalwareDetector()
    return detector.analyze(content, filename)


if __name__ == "__main__":
    # Test with KONNI-style pattern
    konni_sample = """
    # This script ensures that only one instance of this UUID-based project runs at a time.
    # It sends system info via HTTP GET every 13 minutes.
    $projectId = ""  # <- your permanent project UUID

    # ===== NETWORK MODULE =====
    $d=[IO.File]::ReadAllBytes("C:\\ProgramData\\payload.ps1")
    $b=[Text.Encoding]::UTF8.GetBytes("Q")
    for($i=0;$i -lt $d.Length;$i++){$d[$i]=$d[$i]-bxor$b[$i%$b.Length]}
    $c=[Text.Encoding]::UTF8.GetString($d)
    IEX $c

    schtasks /create /sc hourly /tn "OneDrive Startup Task" /tr "powershell -w h ..."
    """

    result = detect_ai_malware(konni_sample)
    print(f"AI Generated: {result.is_ai_generated}")
    print(f"Malicious: {result.is_malicious}")
    print(f"Confidence: {result.confidence:.2f}")
    print(f"Indicators: {result.indicators}")
    print(f"Attribution: {result.attribution}")
