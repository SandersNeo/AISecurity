//! Packet Device â€” Channel between WinDivert and netstack-smoltcp
//!
//! This module provides the bridge that allows WinDivert-captured packets
//! to be processed by the smoltcp user-space TCP/IP stack.

#![allow(unused)]

use std::collections::VecDeque;
use std::sync::{Arc, Mutex};
use tokio::sync::mpsc;
use tracing::{debug, info};

/// Size of the packet queue
const PACKET_QUEUE_SIZE: usize = 4096;

/// A packet captured from WinDivert with its metadata
#[derive(Clone)]
pub struct CapturedPacket {
    /// Raw IP packet data
    pub data: Vec<u8>,
    /// Original source IP (for NAT table)
    pub original_src_ip: [u8; 4],
    /// Original source port
    pub original_src_port: u16,
    /// Original destination IP
    pub original_dst_ip: [u8; 4],
    /// Original destination port
    pub original_dst_port: u16,
    /// Process ID that owns this connection
    pub pid: Option<u32>,
}

/// Sends packets from WinDivert to smoltcp stack
pub struct PacketFeeder {
    tx: mpsc::Sender<CapturedPacket>,
}

impl PacketFeeder {
    /// Feed a captured packet into the smoltcp stack
    pub async fn feed(&self, packet: CapturedPacket) -> Result<(), mpsc::error::SendError<CapturedPacket>> {
        self.tx.send(packet).await
    }
    
    /// Non-blocking feed (for use in sync context)
    pub fn try_feed(&self, packet: CapturedPacket) -> Result<(), mpsc::error::TrySendError<CapturedPacket>> {
        self.tx.try_send(packet)
    }
}

/// Receives packets from smoltcp stack for re-injection via WinDivert
pub struct PacketCollector {
    rx: mpsc::Receiver<Vec<u8>>,
}

impl PacketCollector {
    /// Receive a packet generated by smoltcp for re-injection
    pub async fn collect(&mut self) -> Option<Vec<u8>> {
        self.rx.recv().await
    }
}

/// Sender for outgoing packets from smoltcp
#[derive(Clone)]
pub struct PacketInjector {
    tx: mpsc::Sender<Vec<u8>>,
}

impl PacketInjector {
    /// Send a packet generated by smoltcp for WinDivert re-injection
    pub async fn inject(&self, data: Vec<u8>) -> Result<(), mpsc::error::SendError<Vec<u8>>> {
        self.tx.send(data).await
    }
}

/// Receiver for incoming packets to feed into smoltcp
pub struct PacketReceiver {
    rx: mpsc::Receiver<CapturedPacket>,
}

impl PacketReceiver {
    /// Receive a packet from WinDivert for smoltcp processing
    pub async fn receive(&mut self) -> Option<CapturedPacket> {
        self.rx.recv().await
    }
}

/// Create a complete packet channel system for WinDivert <-> smoltcp communication
/// 
/// Returns:
/// - PacketFeeder: Send captured packets from WinDivert to smoltcp
/// - PacketCollector: Receive packets from smoltcp for WinDivert re-injection
/// - PacketReceiver: Used by smoltcp runner to receive packets
/// - PacketInjector: Used by smoltcp runner to send packets
pub fn create_packet_channels() -> (PacketFeeder, PacketCollector, PacketReceiver, PacketInjector) {
    // Channel: WinDivert -> smoltcp (incoming packets)
    let (in_tx, in_rx) = mpsc::channel::<CapturedPacket>(PACKET_QUEUE_SIZE);
    
    // Channel: smoltcp -> WinDivert (outgoing packets)
    let (out_tx, out_rx) = mpsc::channel::<Vec<u8>>(PACKET_QUEUE_SIZE);
    
    info!("ðŸ“¦ Packet channels created (queue size: {})", PACKET_QUEUE_SIZE);
    
    (
        PacketFeeder { tx: in_tx },
        PacketCollector { rx: out_rx },
        PacketReceiver { rx: in_rx },
        PacketInjector { tx: out_tx },
    )
}

/// NAT table for mapping connections to original destinations
/// Required because smoltcp receives modified packets
#[derive(Default)]
pub struct NatTable {
    /// Map: (client_port) -> (original_dst_ip, original_dst_port, pid)
    entries: Mutex<std::collections::HashMap<u16, ([u8; 4], u16, Option<u32>)>>,
}

impl NatTable {
    pub fn new() -> Self {
        Self::default()
    }
    
    /// Register a connection for NAT lookup
    pub fn register(&self, client_port: u16, dst_ip: [u8; 4], dst_port: u16, pid: Option<u32>) {
        let mut entries = self.entries.lock().unwrap();
        entries.insert(client_port, (dst_ip, dst_port, pid));
        debug!("NAT: registered port {} -> {:?}:{}", client_port, dst_ip, dst_port);
    }
    
    /// Lookup original destination for a client port
    pub fn lookup(&self, client_port: u16) -> Option<([u8; 4], u16, Option<u32>)> {
        let entries = self.entries.lock().unwrap();
        entries.get(&client_port).copied()
    }
    
    /// Remove a connection from the NAT table
    pub fn remove(&self, client_port: u16) {
        let mut entries = self.entries.lock().unwrap();
        entries.remove(&client_port);
    }
    
    /// Clean up stale entries (connections older than TTL)
    pub fn cleanup(&self, max_entries: usize) {
        let mut entries = self.entries.lock().unwrap();
        if entries.len() > max_entries {
            // Simple cleanup: remove oldest entries
            let remove_count = entries.len() - max_entries;
            let keys: Vec<_> = entries.keys().take(remove_count).cloned().collect();
            for key in keys {
                entries.remove(&key);
            }
            debug!("NAT: cleaned up {} stale entries", remove_count);
        }
    }
}

/// Global NAT table instance
pub static NAT_TABLE: once_cell::sync::Lazy<NatTable> = 
    once_cell::sync::Lazy::new(NatTable::new);
